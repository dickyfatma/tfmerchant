
/**
 * .merge (a, b)
 *
 * Simple object merge from source to target.
 *
 * @param {Object} target object
 * @param {Object} source object
 * @name merge
 * @api public
 */

exports.merge = function (a, b){
  if (a && b) {
    for (var key in b) {
      a[key] = b[key];
    }
  }
  return a;
};

/**
 * .defaults (a, b)
 *
 * Simple object defaults for undefined of target
 * from source.
 *
 * @param {Object} target object
 * @param {OBject} source object
 * @name merge
 * @api public
 */

exports.defaults = function (a, b) {
  if (a && b) {
    for (var key in b) {
      if ('undefined' == typeof a[key]) a[key] = b[key];
    }
  }
  return a;
};

/**
 * .deepMerge (a, b)
 *
 * Deep object merge from source to target.
 * Can also use an array as the base.
 *
 * @param {Mixed} target object
 * @param {Mixed} source object
 * @name merge
 * @api public
 */

exports.deepMerge = function (a, b) {
  var arr = Array.isArray(b)
    , dest = arr ? [] : {};

  // if source is array
  if (arr) {
    a = a || [];
    dest = dest.concat(a);
    for (var i = 0; i < b.length; i++) {
      var v = b[i];
      if ('object' == typeof v)
        dest[i] = exports.deepMerge(a[i], v);
      else if (!~a.indexOf(v))
        dest.push(v);
    }

  // everything else (objects too)
  } else {
    // if target is and object
    if (a && 'object' === typeof a) {
      var ak = Object.keys(a);
      for (var i = 0; i < ak.length; i++)
        dest[ak[i]] = a[ak[i]];
    }

    var bk = Object.keys(b);
    for (var ii = 0; ii < bk.length; ii++) {
      var k = bk[ii];
      if ('object' !== typeof b[k] || !b[k]) {
        dest[k] = b[k];
      } else {
        if (a && !a[k]) a[k] = Array.isArray(b[k]) ? [] : {};
        dest[k] = exports.deepMerge(a[k], b[k]);
      }
    }
  }

  return dest;
};
